"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const discord_js_1 = require("discord.js");
const open_trivia_db_1 = require("open-trivia-db");
const EmbedGenerator_1 = require("./EmbedGenerator");
const messageActionRows_1 = require("../Components/messageActionRows");
const util_1 = require("util");
const events_1 = require("events");
const prepareCustomQuestions_1 = require("../Functions/prepareCustomQuestions");
const wait = (0, util_1.promisify)(setTimeout);
function reply(int, obj) {
    return __awaiter(this, void 0, void 0, function* () {
        if (int.replied) {
            yield int.followUp(obj);
        }
        else {
            yield int.reply(obj);
        }
    });
}
/**
 * @class Class for trivia games. Holds dynamic data relating to the ongoing game.
 */
class TriviaGame extends events_1.EventEmitter {
    constructor(component, manager, options) {
        super();
        this.manager = manager;
        this.component = component;
        this.channel = component.channel;
        this.guild = component.guild;
        this.players = new discord_js_1.Collection();
        this.questions = [];
        this.hostMember = component.hostMember;
        this.leaderboard = new discord_js_1.Collection();
        this.options = {};
        this.options = options
            ? Object.assign(TriviaGame.defaults, options)
            : TriviaGame.defaults;
        this.state = "pending";
        this.embeds = new EmbedGenerator_1.default(this);
        this.messages = new discord_js_1.Collection();
        setImmediate(() => {
            this.emit("pending");
        });
    }
    /**
     * Starts the trivia match.
     */
    start() {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            if (this.state == "ended")
                return;
            this.options.questionData = Object.assign({
                category: null,
                amount: 10,
                difficulty: null,
                type: null,
            }, this.options.questionData);
            try {
                this.manager.validator.validateDiscordStructures(this);
                this.manager.validator.validateGameOptions(this.options);
                this.manager.games.set(this.channel.id, this);
                yield this.startComponentCollector();
                yield this.component.reply[this.component.type]({
                    content: "Game has started. Click the join button to enter",
                    ephemeral: true,
                });
                this.state = "queue";
                setImmediate(() => {
                    this.emit("queue");
                });
            }
            catch (err) {
                this.state = "ended";
                this.emit("ended");
                this.component.followUp[this.component.type]({
                    content: err.message,
                    ephemeral: true,
                });
                reject(err);
            }
        }));
    }
    /**
     * The data of this game.
     * @type {TriviaGameResultData}
     */
    data() {
        const playerData = this.players.map((p) => {
            return {
                id: p.id,
                points: p.points,
            };
        });
        const resultData = {
            gameConfiguration: this.options,
            hostMemberId: this.hostMember.id,
            players: playerData,
        };
        return resultData;
    }
    /**
     * Ends this game
     */
    end() {
        this.manager.games.delete(this.channel.id);
        this.state = "ended";
        setImmediate(() => {
            this.emit("ended", this.data());
        });
    }
    /**
     * Starts iterating through TriviaGame#questions and emits each.
     * @private
     */
    beginGameLoop() {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                for (var _b = __asyncValues(this.questions), _c; _c = yield _b.next(), !_c.done;) {
                    const question = _c.value;
                    if (this.state == "ended")
                        return;
                    const msg = yield this.channel.send({
                        content: "ðŸ•¥ **Preparing the next question...**",
                    });
                    this.messages.set(msg.id, msg);
                    yield wait(this.options.timeBetweenRounds);
                    yield this.emitQuestion(question);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            const msg1 = yield this.channel.send({
                embeds: [this.embeds.finalLeaderboard().toJSON()],
            });
            this.messages.set(msg1.id, msg1);
            this.end();
        });
    }
    /**
     * Prepares the game's data and channel for the next round.
     */
    prepareNextRound() {
        return __awaiter(this, void 0, void 0, function* () {
            this.messages
                .filter((msg) => msg.deletable)
                .forEach((msg) => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield msg.delete();
                }
                catch (_) {
                    return void 0;
                }
            }));
            this.players.forEach((p) => {
                if (!p.hasAnswered) {
                    p.correctAnswerStreak = 0;
                }
                p.hasAnswered = false;
                p.isCorrect = false;
            });
            this.updateLeaderboard();
        });
    }
    /**
     * Calculates the amount of points to award the player.
     * @param {number} timePassed - The amount of time elapsed since the question's emission in ms.
     * @private
     */
    calculatePoints(timePassed) {
        const { timePerQuestion, maximumPoints: maxPoints, minimumPoints: minPoints, } = this.options;
        const timeProportion = Number((timePassed / timePerQuestion).toPrecision(2));
        const points = maxPoints - Math.ceil((maxPoints - minPoints) * timeProportion);
        return points;
    }
    /**
     * Sends a question in the game's text channel and listens for answers.
     * @param {Question} question - The question to send.
     * @private
     */
    emitQuestion(question) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                if (this.state == "ended")
                    return;
                const msg = yield this.channel.send({
                    embeds: [this.embeds.question(question).toJSON()],
                    components: [TriviaGame.buttonRows[question.type].toJSON()],
                });
                this.messages.set(msg.id, msg);
                const collector = this.channel.createMessageComponentCollector({
                    time: this.options.timePerQuestion,
                });
                const emissionTime = performance.now();
                collector.on("collect", (i) => __awaiter(this, void 0, void 0, function* () {
                    if (this.state == "ended")
                        return;
                    const answerTime = performance.now();
                    let timeElapsed = answerTime - emissionTime - 500; // -500ms to account for API lag
                    if (timeElapsed > this.options.timePerQuestion)
                        return;
                    const player = this.players.get(i.user.id);
                    if (!player) {
                        return void reply(i, {
                            content: "âŒ You are not apart of this match",
                            ephemeral: true,
                        });
                    }
                    else if (player.hasAnswered) {
                        return void (yield reply(i, {
                            content: "â— **You have already chosen an answer**",
                            ephemeral: true,
                        }));
                    }
                    player.hasAnswered = true;
                    const answer = (question.type == "multiple" ? question.allAnswers : ["False", "True"])[Number(i.customId)];
                    player.isCorrect = question.checkAnswer(`${answer}`);
                    if (player.isCorrect) {
                        player.points += this.calculatePoints(timeElapsed);
                        player.correctAnswerStreak++;
                        if (player.correctAnswerStreak >= this.options.streakDefinitionLevel) {
                            const streakBonus = Math.min(Math.max((player.correctAnswerStreak -
                                (this.options.streakDefinitionLevel - 1)) *
                                this.options.pointsPerStreakAmount, 0), this.options.maximumStreakBonus);
                            player.points += streakBonus;
                        }
                    }
                    else {
                        player.isCorrect = false;
                        player.correctAnswerStreak = 0;
                    }
                    yield reply(i, {
                        content: `ðŸ”¹ Your answer has been locked in!\n\nâš¡ **Speed: ${+(timeElapsed / 1000).toFixed(2)} seconds**`,
                        ephemeral: true,
                    });
                    const member = yield this.guild.members.fetch(player.id);
                    const msg1 = yield this.channel.send({
                        content: `**${member.displayName}** has locked in!`,
                    });
                    this.messages.set(msg1.id, msg1);
                }));
                collector.on("end", () => __awaiter(this, void 0, void 0, function* () {
                    if (this.state == "ended")
                        return;
                    this.players
                        .filter((p) => !p.hasAnswered)
                        .forEach((p) => (p.correctAnswerStreak = 0));
                    const msg2 = yield this.channel.send({
                        embeds: [this.embeds.leaderboardUpdate(question).toJSON()],
                    });
                    setTimeout(() => {
                        if (msg2.deletable) {
                            msg2.delete().catch((_) => null);
                        }
                    }, 10000);
                    yield this.prepareNextRound();
                    yield wait(this.options.timeBetweenRounds);
                    resolve();
                }));
            }));
        });
    }
    /**
     * Starts the chain of private functions to start the game.
     * @private
     */
    initializeGame() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.state == "ended")
                return;
            const data = this.options.questionData;
            if (typeof data == "object" && !Array.isArray(data) && data !== null) {
                const { amount, difficulty, type, category } = data;
                this.questions = yield (0, open_trivia_db_1.getQuestions)({
                    amount,
                    difficulty: difficulty,
                    type: type,
                    category: category,
                });
                if (data === null || data === void 0 ? void 0 : data.customQuestions) {
                    if (data.amount <= data.customQuestions.length) {
                        this.questions = (0, prepareCustomQuestions_1.default)(data.customQuestions.slice(0, data.amount));
                    }
                    else {
                        this.questions = open_trivia_db_1.OpenTDBUtil.shuffleArray([
                            ...this.questions,
                            ...(0, prepareCustomQuestions_1.default)(data.customQuestions),
                        ]);
                    }
                }
            }
            else if (Array.isArray(data)) {
                this.questions = (0, prepareCustomQuestions_1.default)(data);
            }
            else {
                throw new TypeError(`Provided QuestionData must be of type QuestionData | CustomQuestion[], recieved ${typeof data}`);
            }
            const msg = yield this.channel.send({
                embeds: [this.embeds.gameStart().toJSON()],
            });
            this.updateLeaderboard();
            this.messages.set(msg.id, msg);
            yield this.beginGameLoop();
        });
    }
    /**
     * Sets up a listener to collect answers.
     * @private
     */
    startComponentCollector() {
        return __awaiter(this, void 0, void 0, function* () {
            const msg = yield this.channel.send({
                embeds: [this.embeds.gameQueueStart().toJSON()],
                components: [TriviaGame.buttonRows.queue.toJSON()],
            });
            this.messages.set(msg.id, msg);
            const collector = this.channel.createMessageComponentCollector({
                time: this.options.queueTime,
            });
            collector.on("collect", (int) => __awaiter(this, void 0, void 0, function* () {
                if (this.state == "ended")
                    return;
                if (this.players.has(int.user.id)) {
                    const inQueueAlready = {
                        content: "â— **You are already in the queue**",
                        ephemeral: true,
                    };
                    yield reply(int, inQueueAlready);
                }
                else {
                    const member = yield this.guild.members.fetch(int.user.id);
                    if (!member) {
                        reply(int, {
                            content: "âŒ Failed to enter you into the queue, please try again",
                            ephemeral: true,
                        });
                        return;
                    }
                    const joinedQueue = {
                        content: "âœ… Successfully joined queue",
                        ephemeral: true,
                    };
                    yield reply(int, joinedQueue);
                    const player = Object.assign(member, {
                        points: 0,
                        hasAnswered: false,
                        isCorrect: false,
                        correctAnswerStreak: 0,
                    });
                    this.players.set(player.id, player);
                    this.emit("playerJoinQueue", player);
                    const msg1 = yield this.channel.send({
                        content: `ðŸ™Œ   **${player.displayName}** has joined in!`,
                    });
                    this.messages.set(msg1.id, msg1);
                    if (this.players.size === this.options.maximumPlayerCount) {
                        collector.stop("Game has reached set maximum player capacity");
                    }
                }
            }));
            collector.on("end", () => __awaiter(this, void 0, void 0, function* () {
                if (this.state == "ended")
                    return;
                if (this.players.size >= this.options.minimumPlayerCount) {
                    yield this.initializeGame();
                }
                else {
                    this.end();
                    const msg2 = yield this.channel.send({
                        content: "Game failed to meet minimum player requirements",
                    });
                    this.messages.set(msg2.id, msg2);
                }
            }));
        });
    }
    /**
     * Updates data in the game's leaderboard
     * @private
     */
    updateLeaderboard() {
        this.leaderboard = this.players.sort((a, b) => {
            return b.points - a.points;
        });
    }
}
TriviaGame.defaults = {
    questionData: {
        category: null,
        amount: 10,
        difficulty: null,
        type: null,
    },
    minimumPlayerCount: 1,
    maximumPlayerCount: 50,
    timePerQuestion: 20000,
    queueTime: 15000,
    minimumPoints: 1,
    maximumPoints: 100,
    timeBetweenRounds: 6000,
    pointsPerStreakAmount: 10,
    maximumStreakBonus: 30,
    streakDefinitionLevel: 3,
};
TriviaGame.buttonRows = {
    multiple: messageActionRows_1.buttonRowChoicesMultiple,
    boolean: messageActionRows_1.buttonRowChoicesBoolean,
    queue: messageActionRows_1.buttonRowQueue,
};
exports.default = TriviaGame;
